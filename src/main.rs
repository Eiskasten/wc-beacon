use std::error::Error;
use std::ops::Add;
use std::result::Result;
use std::thread;
use std::time::Duration;

use crc::{Crc, CRC_32_ISO_HDLC};

use crate::GGID::{English, French, German, Italian, Japanese, Korean, Spanish};

type MacAddress = [u8; 6];

const CRC_32: Crc<u32> = Crc::<u32>::new(&CRC_32_ISO_HDLC);

fn main() -> Result<(), Box<dyn Error>> {
    let dev_name = "wlp0s20f3";
    let dev_addr: MacAddress = [0x94, 0xe6, 0xf7, 0x06, 0xcf, 0x6b];
    let broadcast_addr: MacAddress = [0xff, 0xff, 0xff, 0xff, 0xff, 0xff];

    eprintln!("Use device '{}' with ethernet address '{:02x?}' and broadcast address '{:02x?}'", dev_name, dev_addr, broadcast_addr);
    let mut cap = pcap::Capture::from_device(dev_name)?.open()?;
    let mut counter: u64 = 0;
    loop {
        let dumped_radio: &[u8] = &[
            0x00, 0x00, // rev, pad
            0x38, 0x00, // header length
            0x2f, 0x40, 0x40, 0xa0, 0x20, 0x08, 0x00, 0xa0, 0x20, 0x08, 0x00, 0x00, // present flags
            0x4d, 0x6c, 0xb8, 0x06, 0x00, 0x00, 0x00, 0x00, // MAC timestamp, update
            0x12, // flags
            0x04, // data rate
            0x8a, 0x09, // channel frequency
            0xa0, 0x00, // channel flags
            0xbd, // antenna signal
            0x00, // ?
            0x00, 0x00, // rx flags
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ?
            0xee, 0x6b, 0xb8, 0x06, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x11, 0x03, // timestamp information, update
            0xbc, // antenna signal
            0x00, // antenna
            0xbd, // antenna signal
            0x01 // antenna
        ];
        let sequence = (counter << 4).to_le_bytes();
        let beacon_frame: &[u8] = &[
            0x80, 0x00, // frame control field (type, subtype)
            0x00, 0x00, // duration
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // destination address
            0xa4, 0xc0, 0xe1, 0x6e, 0x76, 0x80, // source address
            0xa4, 0xc0, 0xe1, 0x6e, 0x76, 0x80, // bssid
            0x40, 0xd0 // sequence number, fragment number, update increment by 0x10
        ];
        let wireless_management: &[u8] = &[
            // fixed parameters
            0xcc, 0xc8, 0x08, 0x2f, 0x00, 0x00, 0x00, 0x00, // timestamp, update
            0x0a, 0x00, // beacon interval
            0x21, 0x00, // capabilities information
            // tagged parameters
            0x01, 0x02, 0x82, 0x84, // tag supported rates
            0x03, 0x01, 0x07, // ds parameter set, current channel
            0x05, 0x05, 0x01, 0x02, 0x00, 0x00, 0x00, // traffic indication map, update
            // vendor specific
            0xdd, // tag number
            0x88, // tag length
            0x00, 0x09, 0xbf, // OUI
            0x00, // OUI type
            0x0a, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x18, 0x03, 0x40, 0x00, 0x00, 0x00, 0x70, 0x00, 0x28, 0x00, 0x0c, 0x00, 0xc5, 0xbd, 0x00, 0x00, 0xa8, 0x03, 0x00, 0x00, 0x03, 0xfc, 0x9f, 0xa4, 0x77, 0xa3, 0x6f, 0x56, 0x7c, 0x17, 0xb7, 0x56, 0x0e, 0x87, 0x38, 0xd8, 0xbc, 0x37, 0x71, 0x29, 0x9c, 0x0c, 0x4c, 0xd1, 0xba, 0x4d, 0xc0, 0x01, 0xd4, 0xbc, 0x81, 0x5b, 0xdd, 0xe6, 0x46, 0xd1, 0x57, 0x66, 0x95, 0x58, 0x81, 0x08, 0x1e, 0x69, 0x06, 0xe4, 0x93, 0x9b, 0xa8, 0x5f, 0xb7, 0x3a, 0x4f, 0x9a, 0xaa, 0x9b, 0x76, 0x86, 0xa7, 0xe8, 0x7f, 0xfd, 0x48, 0x60, 0xdf, 0x45, 0x2a, 0x6d, 0x30, 0x85, 0xa1, 0x8f, 0x1d, 0x3c, 0xb0, 0x70, 0x1e, 0xe1, 0x22, 0x7e, 0x70, 0x8e, 0x64, 0x67, 0xa4, 0xfd, 0xbf, 0xb1, 0xdb, 0x5d, 0xd2, 0x51, 0x02, 0xb0, 0x12, 0x6f, 0x88, 0xb9, 0x72, 0xb0, 0x77, 0xec, 0x84, 0x5e,
        ];
        let mut header_plus_body = [
            beacon_frame,
            wireless_management
        ].concat();
        let recalc_crc = CRC_32.checksum(header_plus_body.as_slice());

        let packet = [
            dumped_radio,
            header_plus_body.as_slice(),
            &recalc_crc.to_le_bytes()
        ].concat();
        cap.sendpacket(packet.as_slice())?;

        counter += 1;
        thread::sleep(Duration::from_secs(1));
    }
}

#[repr(u32)]
enum GGID {
    Japanese = 0x345,
    English = 0x400318,
    French = 0x8000cd,
    German = 0x8000ce,
    Italian = 0x8000cf,
    Spanish = 0x8000d0,
    Korean = 0xc00018,
}

impl TryFrom<&str> for GGID {
    type Error = String;

    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "jp" => Ok(Japanese),
            "en" => Ok(English),
            "fr" => Ok(French),
            "de" => Ok(German),
            "it" => Ok(Italian),
            "es" => Ok(Spanish),
            "ko" => Ok(Korean),
            _ => Err(String::from("Unknown language code: ").add(value))
        }
    }
}